(window["webpackJsonpGUI"] = window["webpackJsonpGUI"] || []).push([["addon-entry-block-count"],{

/***/ "./src/addons/addons/block-count/_runtime_entry.js":
/*!*********************************************************!*\
  !*** ./src/addons/addons/block-count/_runtime_entry.js ***!
  \*********************************************************/
/*! exports provided: resources */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resources", function() { return resources; });
/* harmony import */ var _blockcount_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./blockcount.js */ "./src/addons/addons/block-count/blockcount.js");
/* generated by pull.js */

var resources = {
  "blockcount.js": _blockcount_js__WEBPACK_IMPORTED_MODULE_0__["default"]
};

/***/ }),

/***/ "./src/addons/addons/block-count/blockcount.js":
/*!*****************************************************!*\
  !*** ./src/addons/addons/block-count/blockcount.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/* harmony default export */ __webpack_exports__["default"] = (function (_x) {
  return _ref2.apply(this, arguments);
});

function _ref2() {
  _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(_ref) {
    var addon, console, msg, vm, getBlockCount, addLiveBlockCount;
    return regeneratorRuntime.wrap(function _callee4$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            addon = _ref.addon, console = _ref.console, msg = _ref.msg;
            vm = addon.tab.traps.vm;

            getBlockCount = function getBlockCount() {
              var blockCount = 0;
              var scriptCount = 0;
              var sprites = new Set(vm.runtime.targets.map(function (i) {
                return i.sprite.blocks._blocks;
              }));
              sprites.forEach(function (sprite, i) {
                scriptCount += Object.values(sprite).filter(function (o) {
                  return !o.parent;
                }).length; // Filter blocks that don't have a parent (meaning it's the top of a stack)

                blockCount += Object.values(sprite).filter(function (o) {
                  return !o.shadow;
                }).length; // shadow blocks should be filtered out
              });
              return {
                blockCount: blockCount,
                scriptCount: scriptCount,
                spriteCount: sprites.size - 1 // Backdrop counts as a target so we can subtract it

              };
            };

            addLiveBlockCount = /*#__PURE__*/function () {
              var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
                var handler, _loop, timeout;

                return regeneratorRuntime.wrap(function _callee3$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        if (!vm.editingTarget) {
                          _context4.next = 9;
                          break;
                        }

                        handler = null;
                        _loop = /*#__PURE__*/regeneratorRuntime.mark(function _loop() {
                          var topBar, display, debounce;
                          return regeneratorRuntime.wrap(function _loop$(_context3) {
                            while (1) {
                              switch (_context3.prev = _context3.next) {
                                case 0:
                                  _context3.next = 2;
                                  return addon.tab.waitForElement("[class^='menu-bar_main-menu']", {
                                    markAsSeen: true,
                                    reduxEvents: ["scratch-gui/mode/SET_PLAYER", "fontsLoaded/SET_FONTS_LOADED", "scratch-gui/locales/SELECT_LOCALE"],
                                    reduxCondition: function reduxCondition(state) {
                                      return !state.scratchGui.mode.isPlayerOnly;
                                    }
                                  });

                                case 2:
                                  topBar = _context3.sent;
                                  display = topBar.appendChild(document.createElement("span"));
                                  addon.tab.displayNoneWhileDisabled(display);
                                  display.style.order = 1;
                                  display.style.padding = "9px";
                                  display.innerText = msg("blocks", {
                                    num: getBlockCount().blockCount
                                  });
                                  debounce = void 0; // debouncing values because of the way 'PROJECT_CHANGED' works

                                  if (handler) {
                                    vm.off("PROJECT_CHANGED", handler);
                                    vm.runtime.off("PROJECT_LOADED", handler);
                                  }

                                  handler = /*#__PURE__*/function () {
                                    var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                                      return regeneratorRuntime.wrap(function _callee2$(_context2) {
                                        while (1) {
                                          switch (_context2.prev = _context2.next) {
                                            case 0:
                                              clearTimeout(debounce);
                                              debounce = setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                                                return regeneratorRuntime.wrap(function _callee$(_context) {
                                                  while (1) {
                                                    switch (_context.prev = _context.next) {
                                                      case 0:
                                                        display.innerText = msg("blocks", {
                                                          num: getBlockCount().blockCount
                                                        });

                                                      case 1:
                                                      case "end":
                                                        return _context.stop();
                                                    }
                                                  }
                                                }, _callee);
                                              })), 1000);

                                            case 2:
                                            case "end":
                                              return _context2.stop();
                                          }
                                        }
                                      }, _callee2);
                                    }));

                                    return function handler() {
                                      return _ref4.apply(this, arguments);
                                    };
                                  }();

                                  vm.on("PROJECT_CHANGED", handler);
                                  vm.runtime.on("PROJECT_LOADED", handler);

                                case 13:
                                case "end":
                                  return _context3.stop();
                              }
                            }
                          }, _loop);
                        });

                      case 3:
                        if (false) {}

                        return _context4.delegateYield(_loop(), "t0", 5);

                      case 5:
                        _context4.next = 3;
                        break;

                      case 7:
                        _context4.next = 10;
                        break;

                      case 9:
                        timeout = setTimeout(function () {
                          addLiveBlockCount();
                          clearTimeout(timeout);
                        }, 1000);

                      case 10:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee3);
              }));

              return function addLiveBlockCount() {
                return _ref3.apply(this, arguments);
              };
            }();

            addLiveBlockCount();

          case 5:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee4);
  }));
  return _ref2.apply(this, arguments);
}

/***/ })

}]);
//# sourceMappingURL=addon-entry-block-count.js.map