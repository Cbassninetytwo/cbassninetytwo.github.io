(window["webpackJsonpGUI"] = window["webpackJsonpGUI"] || []).push([["addon-entry-default-costume-editor-color"],{

/***/ "./src/addons/addons/default-costume-editor-color/_runtime_entry.js":
/*!**************************************************************************!*\
  !*** ./src/addons/addons/default-costume-editor-color/_runtime_entry.js ***!
  \**************************************************************************/
/*! exports provided: resources */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resources", function() { return resources; });
/* harmony import */ var _userscript_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./userscript.js */ "./src/addons/addons/default-costume-editor-color/userscript.js");
/* generated by pull.js */

var resources = {
  "userscript.js": _userscript_js__WEBPACK_IMPORTED_MODULE_0__["default"]
};

/***/ }),

/***/ "./src/addons/addons/default-costume-editor-color/userscript.js":
/*!**********************************************************************!*\
  !*** ./src/addons/addons/default-costume-editor-color/userscript.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/* harmony default export */ __webpack_exports__["default"] = (function (_x) {
  return _ref2.apply(this, arguments);
});

function _ref2() {
  _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {
    var addon, global, console, msg, hexComponent, parseColor, parseColorStyleColor, MIXED, SCRATCH_DEFAULT_FILL, SCRATCH_DEFAULT_STROKE, TOOL_INFO, getToolInfo, ColorStyleReducerWrapper, fillStyle, strokeStyle, simpleHexColor, defaultFillColor, defaultStrokeColor, defaultStrokeWidth, setDefaultColorsToSettings, applyFillColor, applyStrokeColor, applyStrokeWidth, isValidColorToPersist, activatingTool;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            addon = _ref.addon, global = _ref.global, console = _ref.console, msg = _ref.msg;
            _context.next = 3;
            return addon.tab.traps.getPaper();

          case 3:
            hexComponent = function hexComponent(str) {
              return Math.round(+str).toString(16).toUpperCase().padStart(2, "0");
            };

            parseColor = function parseColor(color) {
              if (color === null) {
                return null;
              }

              if (typeof color === "string") {
                // TW natively supports hex color codes with or without transparency
                if (color.startsWith("#")) {
                  return color.substring(0, 9).toUpperCase();
                } // Sometimes paper gives us rgb() colors which have to be converted to hex


                var rgbMatch = color.match(/^rgb\((\d+)\s*,(\d+)\s*,(\d+)\)$/);

                if (rgbMatch) {
                  var _rgbMatch = _slicedToArray(rgbMatch, 4),
                      _ = _rgbMatch[0],
                      r = _rgbMatch[1],
                      g = _rgbMatch[2],
                      b = _rgbMatch[3];

                  return "#".concat(hexComponent(r)).concat(hexComponent(g)).concat(hexComponent(b));
                } // It can also give us rgba() colors


                var rgbaMatch = color.match(/^rgba\((\d+)\s*,(\d+)\s*,(\d+),([\d.]+)\)$/);

                if (rgbaMatch) {
                  var _rgbaMatch = _slicedToArray(rgbaMatch, 5),
                      _2 = _rgbaMatch[0],
                      _r = _rgbaMatch[1],
                      _g = _rgbaMatch[2],
                      _b = _rgbaMatch[3],
                      a = _rgbaMatch[4];

                  return "#".concat(hexComponent(_r)).concat(hexComponent(_g)).concat(hexComponent(_b)).concat(hexComponent(a * 255));
                }
              }

              console.log("Could not normalize color", color);
              return null;
            };

            parseColorStyleColor = function parseColorStyleColor(color) {
              if (color === MIXED) return MIXED;
              return parseColor(color);
            }; // Special value Scratch uses as color when objects with different colors are selected
            // https://github.com/LLK/scratch-paint/blob/6733e20b56f52d139f9885952a57c7da012a542f/src/helper/style-path.js#L10


            MIXED = "scratch-paint/style-path/mixed";
            SCRATCH_DEFAULT_FILL = parseColor("#9966FF");
            SCRATCH_DEFAULT_STROKE = parseColor("#000000");
            TOOL_INFO = Object.assign(Object.create(null), {
              // Tool names and gradient info defined in https://github.com/LLK/scratch-paint/blob/develop/src/lib/modes.js
              // Search for activateTool() in matching file in https://github.com/LLK/scratch-paint/tree/develop/src/containers
              BRUSH: {
                resetsFill: true
              },
              ERASER: {},
              LINE: {
                resetsStroke: true,
                requiresNonZeroStrokeWidth: true,
                supportsGradient: true
              },
              FILL: {
                resetsFill: true,
                supportsGradient: true
              },
              SELECT: {
                supportsGradient: true
              },
              RESHAPE: {
                supportsGradient: true
              },
              OVAL: {
                resetsFill: true,
                resetsStroke: true,
                supportsGradient: true
              },
              RECT: {
                resetsFill: true,
                resetsStroke: true,
                supportsGradient: true
              },
              TEXT: {
                resetsFill: true,
                resetsStroke: true
              },
              BIT_BRUSH: {
                resetsFill: true
              },
              BIT_LINE: {
                resetsFill: true,
                requiresNonZeroStrokeWidth: true
              },
              BIT_OVAL: {
                resetsFill: true,
                resetsStroke: true,
                supportsGradient: true
              },
              BIT_RECT: {
                resetsFill: true,
                resetsStroke: true,
                supportsGradient: true
              },
              BIT_TEXT: {
                resetsFill: true,
                resetsStroke: true
              },
              BIT_FILL: {
                resetsFill: true,
                supportsGradient: true
              },
              BIT_ERASER: {},
              BIT_SELECT: {
                supportsGradient: true
              }
            });

            getToolInfo = function getToolInfo() {
              return TOOL_INFO[addon.tab.redux.state.scratchPaint.mode];
            };

            ColorStyleReducerWrapper = /*#__PURE__*/function () {
              function ColorStyleReducerWrapper(reduxPropertyName, primaryAction, secondaryAction, gradientTypeAction) {
                _classCallCheck(this, ColorStyleReducerWrapper);

                this.reduxPropertyName = reduxPropertyName;
                this.primaryAction = primaryAction;
                this.secondaryAction = secondaryAction;
                this.gradientTypeAction = gradientTypeAction;
              }

              _createClass(ColorStyleReducerWrapper, [{
                key: "get",
                value: function get() {
                  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : addon.tab.redux.state;
                  return state.scratchPaint.color[this.reduxPropertyName];
                }
              }, {
                key: "set",
                value: function set(newColor) {
                  var state = this.get();
                  var newPrimary = parseColorStyleColor(newColor.primary);

                  if (state.primary !== newPrimary) {
                    addon.tab.redux.dispatch({
                      type: this.primaryAction,
                      color: newPrimary
                    });
                  }

                  var toolInfo = getToolInfo();
                  var toolSupportsGradient = toolInfo && toolInfo.supportsGradient;

                  if (toolSupportsGradient) {
                    var newSecondary = parseColorStyleColor(newColor.secondary);

                    if (state.secondary !== newSecondary) {
                      addon.tab.redux.dispatch({
                        type: this.secondaryAction,
                        color: newSecondary
                      });
                    }

                    if (state.gradientType !== newColor.gradientType) {
                      addon.tab.redux.dispatch({
                        type: this.gradientTypeAction,
                        gradientType: newColor.gradientType
                      });
                    }
                  }
                }
              }]);

              return ColorStyleReducerWrapper;
            }();

            fillStyle = new ColorStyleReducerWrapper("fillColor", "scratch-paint/fill-style/CHANGE_FILL_COLOR", "scratch-paint/fill-style/CHANGE_FILL_COLOR_2", "scratch-paint/fill-style/CHANGE_FILL_GRADIENT_TYPE");
            strokeStyle = new ColorStyleReducerWrapper("strokeColor", "scratch-paint/stroke-style/CHANGE_STROKE_COLOR", "scratch-paint/stroke-style/CHANGE_STROKE_COLOR_2", "scratch-paint/stroke-style/CHANGE_STROKE_GRADIENT_TYPE");

            simpleHexColor = function simpleHexColor(hex) {
              return {
                primary: hex,
                secondary: null,
                gradientType: "SOLID"
              };
            };

            setDefaultColorsToSettings = function setDefaultColorsToSettings() {
              defaultFillColor = simpleHexColor(parseColor(addon.settings.get("fill")));
              defaultStrokeColor = simpleHexColor(parseColor(addon.settings.get("stroke")));
              defaultStrokeWidth = addon.settings.get("strokeSize");
            };

            setDefaultColorsToSettings();

            applyFillColor = function applyFillColor() {
              fillStyle.set(defaultFillColor);
            };

            applyStrokeColor = function applyStrokeColor() {
              strokeStyle.set(defaultStrokeColor);
            };

            applyStrokeWidth = function applyStrokeWidth(mustBeNonZero) {
              var width = defaultStrokeWidth;

              if (width === 0 && mustBeNonZero) {
                width = 1;
              }

              if (addon.tab.redux.state.scratchPaint.color.strokeWidth !== width) {
                addon.tab.redux.dispatch({
                  type: "scratch-paint/stroke-width/CHANGE_STROKE_WIDTH",
                  strokeWidth: width
                });
              }
            };

            if (!addon.self.disabled) {
              applyFillColor();
              applyStrokeColor();
              applyStrokeWidth(false);
            }

            addon.settings.addEventListener("change", function () {
              if (!addon.settings.get("persistence")) {
                setDefaultColorsToSettings();
              }
            });

            isValidColorToPersist = function isValidColorToPersist(color) {
              return color.primary !== null && color.primary !== MIXED;
            };

            activatingTool = false;
            addon.tab.redux.initialize();
            addon.tab.redux.addEventListener("statechanged", function (_ref3) {
              var detail = _ref3.detail;

              if (addon.self.disabled) {
                return;
              }

              var action = detail.action;

              if (!activatingTool && addon.settings.get("persistence")) {
                // We always want to check for changes instead of filtering to just certain actions because quite a few
                // actions can change these.
                var newFill = fillStyle.get();

                if (fillStyle.get(detail.prev) !== newFill && isValidColorToPersist(newFill)) {
                  defaultFillColor = newFill;
                }

                var newStroke = strokeStyle.get();

                if (strokeStyle.get(detail.prev) !== newStroke && isValidColorToPersist(newStroke)) {
                  defaultStrokeColor = newStroke;
                }

                var newStrokeWidth = detail.next.scratchPaint.color.strokeWidth;

                if (typeof newStrokeWidth === "number") {
                  defaultStrokeWidth = newStrokeWidth;
                }
              }

              if (action.type === "scratch-paint/modes/CHANGE_MODE") {
                activatingTool = true;
                queueMicrotask(function () {
                  activatingTool = false;

                  if (addon.settings.get("persistence")) {
                    // In persistence, we always want to re-apply the previous stroke and fill.
                    var toolInfo = getToolInfo();

                    if (!toolInfo) {
                      console.warn("unknown tool", addon.tab.redux.state.scratchPaint.mode);
                      return;
                    }

                    if (toolInfo.resetsFill) {
                      applyFillColor();
                    }

                    if (toolInfo.resetsStroke) {
                      applyStrokeWidth(!!toolInfo.requiresNonZeroStrokeWidth);
                      applyStrokeColor();
                    }
                  } else {
                    // In non-persistence, we'll only apply the default colors when Scratch resets them to maintain the same behavior.
                    // We have to do this weird redux trick because we can't modify these constants:
                    // https://github.com/LLK/scratch-paint/blob/6733e20b56f52d139f9885952a57c7da012a542f/src/reducers/fill-style.js#L7
                    // https://github.com/LLK/scratch-paint/blob/6733e20b56f52d139f9885952a57c7da012a542f/src/reducers/stroke-style.js#L7
                    var oldFillColor = fillStyle.get(detail.prev);

                    if (oldFillColor.primary === null || oldFillColor.primary === MIXED) {
                      var newFillColor = fillStyle.get();

                      if (newFillColor.primary === SCRATCH_DEFAULT_FILL) {
                        applyFillColor();
                      }
                    }

                    var oldStrokeColor = strokeStyle.get(detail.prev);

                    if (oldStrokeColor.primary === null || oldStrokeColor.primary === MIXED) {
                      var newStrokeColor = strokeStyle.get();

                      if (newStrokeColor.primary === SCRATCH_DEFAULT_STROKE) {
                        applyStrokeWidth(true);
                        applyStrokeColor();
                      }
                    }
                  }
                });
              }
            });

          case 26:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _ref2.apply(this, arguments);
}

/***/ })

}]);
//# sourceMappingURL=addon-entry-default-costume-editor-color.js.map