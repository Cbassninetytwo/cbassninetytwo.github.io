(window["webpackJsonpGUI"] = window["webpackJsonpGUI"] || []).push([["addon-entry-mediarecorder"],{

/***/ "./node_modules/css-loader/index.js!./src/addons/addons/mediarecorder/style.css":
/*!*****************************************************************************!*\
  !*** ./node_modules/css-loader!./src/addons/addons/mediarecorder/style.css ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".mediaRecorderPopup {\n  box-sizing: border-box;\n  width: 700px;\n  max-height: min(800px, 80vh);\n  max-width: 85%;\n  margin-top: 12vh;\n  overflow-y: auto;\n  margin-left: auto;\n  margin-right: auto;\n}\n\n.mediaRecorderPopupContent {\n  padding: 1.5rem 2.25rem;\n}\n\n.mediaRecorderPopup p {\n  font-size: 1rem;\n  margin: 0.5rem auto;\n}\n\n.mediaRecorderPopup p :last-child {\n  margin-left: 1rem;\n}\n\n.mediaRecorderPopup[dir=\"rtl\"] p :last-child {\n  margin-left: 0;\n  margin-right: 1rem;\n}\n\np.mediaRecorderPopupOption {\n  display: flex;\n  align-items: center;\n}\n\n.mediaRecorderPopupOption input[type=\"checkbox\"] {\n  height: 1.5rem;\n}\n\n#recordOptionSecondsInput,\n#recordOptionDelayInput {\n  width: 6rem;\n}\n\n.mediaRecorderPopupButtons {\n  margin-top: 1.5rem;\n}\n\n.mediaRecorderPopupButtons button {\n  margin-left: 0.5rem;\n}\n\n/* TW: Fixes cancel button in dark mode */\n.mediaRecorderPopupButtons button:nth-of-type(1) {\n  color: black;\n}\n", ""]);

// exports


/***/ }),

/***/ "./src/addons/addons/mediarecorder/_runtime_entry.js":
/*!***********************************************************!*\
  !*** ./src/addons/addons/mediarecorder/_runtime_entry.js ***!
  \***********************************************************/
/*! exports provided: resources */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resources", function() { return resources; });
/* harmony import */ var _userscript_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./userscript.js */ "./src/addons/addons/mediarecorder/userscript.js");
/* harmony import */ var _css_loader_style_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! css-loader!./style.css */ "./node_modules/css-loader/index.js!./src/addons/addons/mediarecorder/style.css");
/* harmony import */ var _css_loader_style_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_style_css__WEBPACK_IMPORTED_MODULE_1__);
/* generated by pull.js */


var resources = {
  "userscript.js": _userscript_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  "style.css": _css_loader_style_css__WEBPACK_IMPORTED_MODULE_1___default.a
};

/***/ }),

/***/ "./src/addons/addons/mediarecorder/userscript.js":
/*!*******************************************************!*\
  !*** ./src/addons/addons/mediarecorder/userscript.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _libraries_common_cs_download_blob_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../libraries/common/cs/download-blob.js */ "./src/addons/libraries/common/cs/download-blob.js");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }


/* harmony default export */ __webpack_exports__["default"] = (/*#__PURE__*/(function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref) {
    var addon, console, msg, recordElem, isRecording, isWaitingForFlag, waitingForFlagFunc, abortController, stopSignFunc, recordBuffer, recorder, timeout, _loop;

    return regeneratorRuntime.wrap(function _callee3$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            addon = _ref.addon, console = _ref.console, msg = _ref.msg;
            isRecording = false;
            isWaitingForFlag = false;
            waitingForFlagFunc = null;
            abortController = null;
            stopSignFunc = null;
            recordBuffer = [];
            _loop = /*#__PURE__*/regeneratorRuntime.mark(function _loop() {
              var elem, getOptions, disposeRecorder, stopRecording, startRecording;
              return regeneratorRuntime.wrap(function _loop$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      _context3.next = 2;
                      return addon.tab.waitForElement('div[class*="menu-bar_file-group"] > div:last-child:not(.sa-record)', {
                        markAsSeen: true,
                        reduxEvents: ["scratch-gui/mode/SET_PLAYER", "fontsLoaded/SET_FONTS_LOADED", "scratch-gui/locales/SELECT_LOCALE"]
                      });

                    case 2:
                      elem = _context3.sent;

                      getOptions = function getOptions() {
                        var _addon$tab$createModa = addon.tab.createModal(msg("option-title"), {
                          isOpen: true,
                          useEditorClasses: true
                        }),
                            backdrop = _addon$tab$createModa.backdrop,
                            container = _addon$tab$createModa.container,
                            content = _addon$tab$createModa.content,
                            closeButton = _addon$tab$createModa.closeButton,
                            remove = _addon$tab$createModa.remove;

                        container.classList.add("mediaRecorderPopup");
                        content.classList.add("mediaRecorderPopupContent");
                        content.appendChild(Object.assign(document.createElement("p"), {
                          textContent: msg("record-description"),
                          className: "recordOptionDescription"
                        })); // Seconds

                        var recordOptionSeconds = document.createElement("p");
                        var recordOptionSecondsInput = Object.assign(document.createElement("input"), {
                          type: "number",
                          min: 1,
                          max: 300,
                          defaultValue: 30,
                          id: "recordOptionSecondsInput",
                          className: addon.tab.scratchClass("prompt_variable-name-text-input")
                        });
                        var recordOptionSecondsLabel = Object.assign(document.createElement("label"), {
                          htmlFor: "recordOptionSecondsInput",
                          textContent: msg("record-duration")
                        });
                        recordOptionSeconds.appendChild(recordOptionSecondsLabel);
                        recordOptionSeconds.appendChild(recordOptionSecondsInput);
                        content.appendChild(recordOptionSeconds); // Delay

                        var recordOptionDelay = document.createElement("p");
                        var recordOptionDelayInput = Object.assign(document.createElement("input"), {
                          type: "number",
                          min: 0,
                          max: 300,
                          defaultValue: 0,
                          id: "recordOptionDelayInput",
                          className: addon.tab.scratchClass("prompt_variable-name-text-input")
                        });
                        var recordOptionDelayLabel = Object.assign(document.createElement("label"), {
                          htmlFor: "recordOptionDelayInput",
                          textContent: msg("start-delay")
                        });
                        recordOptionDelay.appendChild(recordOptionDelayLabel);
                        recordOptionDelay.appendChild(recordOptionDelayInput);
                        content.appendChild(recordOptionDelay); // Audio

                        var recordOptionAudio = Object.assign(document.createElement("p"), {
                          className: "mediaRecorderPopupOption"
                        });
                        var recordOptionAudioInput = Object.assign(document.createElement("input"), {
                          type: "checkbox",
                          defaultChecked: true,
                          id: "recordOptionAudioInput"
                        });
                        var recordOptionAudioLabel = Object.assign(document.createElement("label"), {
                          htmlFor: "recordOptionAudioInput",
                          textContent: msg("record-audio"),
                          title: msg("record-audio-description")
                        });
                        recordOptionAudio.appendChild(recordOptionAudioInput);
                        recordOptionAudio.appendChild(recordOptionAudioLabel);
                        content.appendChild(recordOptionAudio); // Mic

                        var recordOptionMic = Object.assign(document.createElement("p"), {
                          className: "mediaRecorderPopupOption"
                        });
                        var recordOptionMicInput = Object.assign(document.createElement("input"), {
                          type: "checkbox",
                          defaultChecked: false,
                          id: "recordOptionMicInput"
                        });
                        var recordOptionMicLabel = Object.assign(document.createElement("label"), {
                          htmlFor: "recordOptionMicInput",
                          textContent: msg("record-mic")
                        });
                        recordOptionMic.appendChild(recordOptionMicInput);
                        recordOptionMic.appendChild(recordOptionMicLabel);
                        content.appendChild(recordOptionMic); // Green flag

                        var recordOptionFlag = Object.assign(document.createElement("p"), {
                          className: "mediaRecorderPopupOption"
                        });
                        var recordOptionFlagInput = Object.assign(document.createElement("input"), {
                          type: "checkbox",
                          defaultChecked: true,
                          id: "recordOptionFlagInput"
                        });
                        var recordOptionFlagLabel = Object.assign(document.createElement("label"), {
                          htmlFor: "recordOptionFlagInput",
                          textContent: msg("record-after-flag")
                        });
                        recordOptionFlag.appendChild(recordOptionFlagInput);
                        recordOptionFlag.appendChild(recordOptionFlagLabel);
                        content.appendChild(recordOptionFlag); // Stop sign

                        var recordOptionStop = Object.assign(document.createElement("p"), {
                          className: "mediaRecorderPopupOption"
                        });
                        var recordOptionStopInput = Object.assign(document.createElement("input"), {
                          type: "checkbox",
                          defaultChecked: true,
                          id: "recordOptionStopInput"
                        });
                        var recordOptionStopLabel = Object.assign(document.createElement("label"), {
                          htmlFor: "recordOptionStopInput",
                          textContent: msg("record-until-stop")
                        });
                        recordOptionFlagInput.addEventListener("change", function () {
                          var disabled = recordOptionStopInput.disabled = !recordOptionFlagInput.checked;

                          if (disabled) {
                            recordOptionStopLabel.title = msg("record-until-stop-disabled", {
                              afterFlagOption: msg("record-after-flag")
                            });
                          }
                        });
                        recordOptionStop.appendChild(recordOptionStopInput);
                        recordOptionStop.appendChild(recordOptionStopLabel);
                        content.appendChild(recordOptionStop);
                        var resolvePromise = null;
                        var optionPromise = new Promise(function (resolve) {
                          resolvePromise = resolve;
                        });
                        var handleOptionClose = null;
                        backdrop.addEventListener("click", function () {
                          return handleOptionClose(null);
                        });
                        closeButton.addEventListener("click", function () {
                          return handleOptionClose(null);
                        });

                        handleOptionClose = function handleOptionClose(value) {
                          resolvePromise(value);
                          remove();
                        };

                        var buttonRow = Object.assign(document.createElement("div"), {
                          className: addon.tab.scratchClass("prompt_button-row", {
                            others: "mediaRecorderPopupButtons"
                          })
                        });
                        var cancelButton = Object.assign(document.createElement("button"), {
                          textContent: msg("cancel")
                        });
                        cancelButton.addEventListener("click", function () {
                          return handleOptionClose(null);
                        }, {
                          once: true
                        });
                        buttonRow.appendChild(cancelButton);
                        var startButton = Object.assign(document.createElement("button"), {
                          textContent: msg("start"),
                          className: addon.tab.scratchClass("prompt_ok-button")
                        });
                        startButton.addEventListener("click", function () {
                          return handleOptionClose({
                            secs: Number(recordOptionSecondsInput.value),
                            delay: Number(recordOptionDelayInput.value),
                            audioEnabled: recordOptionAudioInput.checked,
                            micEnabled: recordOptionMicInput.checked,
                            waitUntilFlag: recordOptionFlagInput.checked,
                            useStopSign: !recordOptionStopInput.disabled && recordOptionStopInput.checked
                          });
                        }, {
                          once: true
                        });
                        buttonRow.appendChild(startButton);
                        content.appendChild(buttonRow);
                        return optionPromise;
                      };

                      disposeRecorder = function disposeRecorder() {
                        isRecording = false;
                        recordElem.textContent = msg("record");
                        recordElem.title = "";
                        recorder = null;
                        recordBuffer = [];
                        clearTimeout(timeout);
                        timeout = 0;

                        if (stopSignFunc) {
                          addon.tab.traps.vm.runtime.off("PROJECT_STOP_ALL", stopSignFunc);
                          stopSignFunc = null;
                        }
                      };

                      stopRecording = function stopRecording(force) {
                        if (isWaitingForFlag) {
                          addon.tab.traps.vm.runtime.off("PROJECT_START", waitingForFlagFunc);
                          isWaitingForFlag = false;
                          waitingForFlagFunc = null;
                          abortController.abort();
                          abortController = null;
                          disposeRecorder();
                          return;
                        }

                        if (!isRecording || !recorder || recorder.state === "inactive") return;

                        if (force) {
                          disposeRecorder();
                        } else {
                          recorder.onstop = function () {
                            var blob = new Blob(recordBuffer, {
                              type: "video/webm"
                            });
                            Object(_libraries_common_cs_download_blob_js__WEBPACK_IMPORTED_MODULE_0__["default"])("video.webm", blob);
                            disposeRecorder();
                          };

                          recorder.stop();
                        }
                      };

                      startRecording = /*#__PURE__*/function () {
                        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(opts) {
                          var secs, vm, micStream, stream, videoStream, ctx, dest, mediaStreamDestination, audioSource, micSource, delay, roundedDelay, index;
                          return regeneratorRuntime.wrap(function _callee$(_context) {
                            while (1) {
                              switch (_context.prev = _context.next) {
                                case 0:
                                  // Timer
                                  secs = Math.min(300, Math.max(1, opts.secs)); // Initialize MediaRecorder

                                  recordBuffer = [];
                                  isRecording = true;
                                  vm = addon.tab.traps.vm;

                                  if (!opts.micEnabled) {
                                    _context.next = 16;
                                    break;
                                  }

                                  _context.prev = 5;
                                  _context.next = 8;
                                  return navigator.mediaDevices.getUserMedia({
                                    audio: true
                                  });

                                case 8:
                                  micStream = _context.sent;
                                  _context.next = 16;
                                  break;

                                case 11:
                                  _context.prev = 11;
                                  _context.t0 = _context["catch"](5);

                                  if (!(_context.t0.name !== "NotAllowedError" && _context.t0.name !== "NotFoundError")) {
                                    _context.next = 15;
                                    break;
                                  }

                                  throw _context.t0;

                                case 15:
                                  opts.micEnabled = false;

                                case 16:
                                  if (!opts.waitUntilFlag) {
                                    _context.next = 30;
                                    break;
                                  }

                                  isWaitingForFlag = true;
                                  Object.assign(recordElem, {
                                    textContent: msg("click-flag"),
                                    title: msg("click-flag-description")
                                  });
                                  abortController = new AbortController();
                                  _context.prev = 20;
                                  _context.next = 23;
                                  return Promise.race([new Promise(function (resolve) {
                                    waitingForFlagFunc = function waitingForFlagFunc() {
                                      return resolve();
                                    };

                                    vm.runtime.once("PROJECT_START", waitingForFlagFunc);
                                  }), new Promise(function (_, reject) {
                                    abortController.signal.addEventListener("abort", function () {
                                      return reject("aborted");
                                    }, {
                                      once: true
                                    });
                                  })]);

                                case 23:
                                  _context.next = 30;
                                  break;

                                case 25:
                                  _context.prev = 25;
                                  _context.t1 = _context["catch"](20);

                                  if (!(_context.t1.message === "aborted")) {
                                    _context.next = 29;
                                    break;
                                  }

                                  return _context.abrupt("return");

                                case 29:
                                  throw _context.t1;

                                case 30:
                                  isWaitingForFlag = false;
                                  waitingForFlagFunc = abortController = null;
                                  stream = new MediaStream();
                                  videoStream = vm.runtime.renderer.canvas.captureStream();
                                  stream.addTrack(videoStream.getVideoTracks()[0]);
                                  ctx = new AudioContext();
                                  dest = ctx.createMediaStreamDestination();

                                  if (opts.audioEnabled) {
                                    mediaStreamDestination = vm.runtime.audioEngine.audioContext.createMediaStreamDestination();
                                    vm.runtime.audioEngine.inputNode.connect(mediaStreamDestination);
                                    audioSource = ctx.createMediaStreamSource(mediaStreamDestination.stream);
                                    audioSource.connect(dest);
                                  }

                                  if (opts.micEnabled) {
                                    micSource = ctx.createMediaStreamSource(micStream);
                                    micSource.connect(dest);
                                  }

                                  if (opts.audioEnabled || opts.micEnabled) {
                                    stream.addTrack(dest.stream.getAudioTracks()[0]);
                                  }

                                  recorder = new MediaRecorder(stream, {
                                    mimeType: "video/webm"
                                  });

                                  recorder.ondataavailable = function (e) {
                                    recordBuffer.push(e.data);
                                  };

                                  recorder.onerror = function (e) {
                                    console.warn("Recorder error:", e.error);
                                    stopRecording(true);
                                  };

                                  timeout = setTimeout(function () {
                                    return stopRecording(false);
                                  }, secs * 1000);

                                  if (opts.useStopSign) {
                                    stopSignFunc = function stopSignFunc() {
                                      return stopRecording();
                                    };

                                    vm.runtime.once("PROJECT_STOP_ALL", stopSignFunc);
                                  } // Delay


                                  delay = opts.delay || 0;
                                  roundedDelay = Math.floor(delay);
                                  index = 0;

                                case 48:
                                  if (!(index < roundedDelay)) {
                                    _context.next = 55;
                                    break;
                                  }

                                  recordElem.textContent = msg("starting-in", {
                                    secs: roundedDelay - index
                                  });
                                  _context.next = 52;
                                  return new Promise(function (resolve) {
                                    return setTimeout(resolve, 975);
                                  });

                                case 52:
                                  index++;
                                  _context.next = 48;
                                  break;

                                case 55:
                                  setTimeout(function () {
                                    recordElem.textContent = msg("stop");
                                    recorder.start(1000);
                                  }, (delay - roundedDelay) * 1000);

                                case 56:
                                case "end":
                                  return _context.stop();
                              }
                            }
                          }, _callee, null, [[5, 11], [20, 25]]);
                        }));

                        return function startRecording(_x2) {
                          return _ref3.apply(this, arguments);
                        };
                      }();

                      if (!recordElem) {
                        recordElem = Object.assign(document.createElement("div"), {
                          className: "sa-record " + elem.className,
                          textContent: msg("record")
                        });
                        recordElem.addEventListener("click", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                          var opts;
                          return regeneratorRuntime.wrap(function _callee2$(_context2) {
                            while (1) {
                              switch (_context2.prev = _context2.next) {
                                case 0:
                                  if (!isRecording) {
                                    _context2.next = 4;
                                    break;
                                  }

                                  stopRecording();
                                  _context2.next = 11;
                                  break;

                                case 4:
                                  _context2.next = 6;
                                  return getOptions();

                                case 6:
                                  opts = _context2.sent;

                                  if (opts) {
                                    _context2.next = 10;
                                    break;
                                  }

                                  console.log("Canceled");
                                  return _context2.abrupt("return");

                                case 10:
                                  startRecording(opts);

                                case 11:
                                case "end":
                                  return _context2.stop();
                              }
                            }
                          }, _callee2);
                        })));
                      }

                      elem.parentElement.appendChild(recordElem);

                    case 9:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _loop);
            });

          case 8:
            if (false) {}

            return _context4.delegateYield(_loop(), "t0", 10);

          case 10:
            _context4.next = 8;
            break;

          case 12:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee3);
  }));

  return function (_x) {
    return _ref2.apply(this, arguments);
  };
})());

/***/ }),

/***/ "./src/addons/libraries/common/cs/download-blob.js":
/*!*********************************************************!*\
  !*** ./src/addons/libraries/common/cs/download-blob.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// From https://github.com/LLK/scratch-gui/blob/develop/src/lib/download-blob.js
/* harmony default export */ __webpack_exports__["default"] = (function (filename, blob) {
  var downloadLink = document.createElement("a");
  document.body.appendChild(downloadLink); // Use special ms version if available to get it working on Edge.

  if (navigator.msSaveOrOpenBlob) {
    navigator.msSaveOrOpenBlob(blob, filename);
    return;
  }

  if ("download" in HTMLAnchorElement.prototype) {
    var url = window.URL.createObjectURL(blob);
    downloadLink.href = url;
    downloadLink.download = filename;
    downloadLink.type = blob.type;
    downloadLink.click(); // remove the link after a timeout to prevent a crash on iOS 13 Safari

    window.setTimeout(function () {
      document.body.removeChild(downloadLink);
      window.URL.revokeObjectURL(url);
    }, 1000);
  } else {
    // iOS 12 Safari, open a new page and set href to data-uri
    var popup = window.open("", "_blank");
    var reader = new FileReader();

    reader.onloadend = function () {
      popup.location.href = reader.result;
      popup = null;
    };

    reader.readAsDataURL(blob);
  }
});

/***/ })

}]);
//# sourceMappingURL=addon-entry-mediarecorder.js.map